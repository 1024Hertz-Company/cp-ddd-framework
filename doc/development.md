# 业务开发

如何更好的构建软件？

致力于前中台解耦、沉淀业务资产、赋能研发编写出知识化的业务系统，使得我们的业务系统具有客户视角、老板视角、产品视角、研发视角、测试视角和业务前台视角。

扩展点对入参、出参、异常等没有规定，但在具体项目里也应充分考虑当前业务抽象度和稳定性。如果扩展点有多个方法，那么就前台中台的耦合性就增加了，一个方法的接口耦合度低。

业务扩展点，建立了前中台的合作机制，同时中台内部也用于解决多场景下相同业务语义不同执行逻辑的用途。
扩展点的合理性，是需要进行深度业务分析、业务抽象的，它要稳定，并预留扩展性。

产生背景
它的产生，是以如下的假想目标，并针对legacy code进行梳理和重构中产生和发展壮大起来的：

如果ECLP的仓配一体订单中心进行彻底重构，该如何进行？

投入3个人搞半年能把ECLP业务切走40%吗，一年能切走70%吗，能保证线上零事故吗
如何让代码结构化，知识化，如何让代码低成本地反映业务，如何让代码成为产品和研发的共同语言；如何让坏味道代码无污染无公害
如何沉淀清晰可复用的业务资产，沉淀到哪里，资产长什么样；哪些不需要沉淀
系统是否支持我以不同粒度不同视角从不同维度低成本地梳理出业务
如何快速响应千奇百怪的个性化需求，同时保持自身不腐化
如何让研发从泥潭中走出来，看到光明，重塑业务研发模式；如何满足不同研发人员的职业规划，从不同维度成长
如何让研发拿到需求立刻就知道代码写在哪里，不各显神通地造轮子造概念


如何让订单中心支持前台、中台协同开发，破除单点，各司其职，人员解耦，开发解耦
如何利用框架来赋能业务开发，让我们的业务系统代码像个中台的样子，中台的代码应该什么样子

中台是业务的入口和驱动者，在业务执行过程中，根据上下文数据自动识别出业务扩展点(接口)的具体实现者，并把控制权交给相应的前台；扩展点方法执行完成后，回到中台继续执行。

考虑到京东物流中台的起步阶段现状，做不到一上来就业务本质思考并合理准确地抽取出业务扩展点，中台架构与传统TOGAF架构方法最大的区别是由于业务的不确定性它只能自下而上，通过归纳总结进行抽象。
因此，业务扩展点的粒度在具体实施过程中，必然要经过开始粗、逐渐细的过程。
粗粒度的扩展点，可以让中台快速响应前台需求，但会造成业务逻辑重心倾斜到前台：中台除了留下了统一入口、领域模型、领域步骤、领域规范、物理模型、数据外，业务沉淀少，即，有了强大的躯干，但肉少，肉长在了前台身上。
理想的合理的扩展点，是细粒度的，肉留在中台，前台可以复用中台能力，前台只起到个性化需求实现作用，即扩展(补充)中台能力。

中台做什么
中台是业务的入口和驱动者，中台提供

数据的存储
业务模型，业务活动和步骤的抽象
业务开发规范
统一的业务字典
让前台利用中台能力可以自行发展的扩展机制，中台不阻塞前台业务
业务治理，技术治理，尤其考虑到多前台冲突、竞争场景
把握整体和未来趋势


前台做什么

前台需要理解中台输出的domain model spec
根据领域模型识别出属于自己的前台业务
根据中台的扩展机制和开发规范进行独立开发
可以对中台提供的领域步骤进行编排
可以对中台的扩展点进行编排，即有些扩展机制要跳过
如果使用了扩展属性机制，需要实现扩展属性的接口，实现个性化业务逻辑
如果有外部依赖，例如引入了另外一个JSF接口或者自己使用的redis，需要配置spring.xml，并提交给中台审批后被import
如果有自己的properties文件，需要自行编写，提交给中台审批后使用
前台可以自行定义错误码，也可以覆盖中台的错误消息话术


业务演化

扩展点粒度由粗变细
扩展点定义变化

扩展点的入参、出参本身是可扩展的
业务语义的变化，可以以新替旧


业务逻辑由前台下沉回中台

代码的改动小，甚至不需要改，风险低，不需要做切流量验证


个性化数据由前台下沉回中台

例如，中台存100个字段，前台A在自己的系统上保存5个字段，后来发现这5个字段其他前台也需要，是通用的
数据是无法低成本下沉回中台的
推荐使用中台提供的扩展属性机制，个性化字段前台尽量让中台满足，不自己搞
如果是属于客户业务前置类字段场景，那是完整的数据库设计，前台自行设计实现，不属于个性化字段范畴

例如，客户希望在下单前走内部的审批流程，这个审批流程希望京东给他实现
这个审批流程会涉及N个表，是自治的解决方案，前台自行解决




最开始业务抽象认为是中台的逻辑，后来发现应该是属于前台逻辑


Q：“晚饭吃了啥？”。  A：“我用勺子一口一口地吃了鸡生下的蛋和番茄再加上油一起炒的菜。”


GoF Design Pattern、EIP、Refactoring、P of EAA，它们的理念是通过技术手段解决技术问题，并没有根本上解决业务的问题


由于DDD不是一套框架，而是一种架构思想，所以在代码层面缺乏了足够的约束，导致DDD在实际应用中上手门槛很高，甚至可以说绝大部分人都对它的理解有所偏差。
绝大部分人在实际应用当中仅仅用到了DDD的建模的思想，而其对于整个架构体系的思想无法落地。
我们需要一套合理的代码结构、分层、框架和约束，来降低DDD的实践门槛，提升代码质量、可测试性、安全性、健壮性：cp-core的DDD框架。

领域知识

- 分层重构
- 架构重构
- 代码重构
- 模式重构
- 数据库重构
- 模块重构
- 领域模型重构

4个不同的重构级别：
架构重构。在不改变业务逻辑的情况下，根据单一职责和依赖倒置原则的思想：对系统进行模块拆分与合并，以明确职责降低耦合度；对包进行重新规划，划分包之间的边界，减少代码间的耦合。
模型重构。在包含测试的情况下，通过识别和发现模型的行为，将行为聚合到模型中：根据方法名称、参数、返回判定内聚到模型中；从流程梳理是否符合业务场景 。
模式重构。对于特定代码坏味道产生的问题，通过结合架构模式、设计模式来提升可读性。如：使用工厂模式统一管理对象的创建；使用策略模式降低复杂度。
代码重构。对于一些小的代码坏味道，可以通过 IDE 重构来快速改善即有代码，而不会影响到业务功能。如：复杂条件语句的提取；使用参数对象重构参数过多。


代码债务：代码风格不一致、静态分析的违规
设计债务：设计坏味道、违反设计原则
测试债务：测试不充分、测试设计不合理
文档债务：缺少文档、文档糟糕及文档过期


C4 代表上下文（Context）、容器（Container）、组件（Component）和代码（Code）——一系列分层的图表，可以用这些图表来描述不同缩放级别的软件架构，每种图表都适用于不同的受众。
换句话来说，C4 模型适用于软件开发团队的各个 level 的成员——架构师、Tech Lead、开发人员、新成员等。也因此，C4 可以直接反应系统的架构原则 ，并能直观地帮助项目的新成员熟悉项目。


带你成为顶尖开发者


技术导向架构模式 MVC


当我们谈论 service 的时候，我们谈论的是同一个 service 吗？

当我们谈论 model 的时候，我们谈论的是同一种 model 吗？


软件开发总成本 = 开发成本 + 维护成本；软件维护成本 = 理解成本 + 修改成本 + 测试成本 + 部署成本 Kent Beck

在需求里面我们往往把约束，完整性，校验，分支流等都可以算到业务规则

awesome ddd, java
https://xie.infoq.cn/
https://www.jianshu.com/

能力建设和架构完善
如何应对异常复杂的积木业务逻辑和不可预知的业务变化，构建业务和底层技术基础实施的完全解耦的系统，一直是我们面对的巨大挑战
也是时候从更高视角来看清问题和源头，思考一种能应对和控制业务复杂度、具备强扩展性和弹性的解决方案。

DDD战略设计到战术设计的方法论和实践。让软件研发所有参与者围绕着一个统一和一致的领域模型建模和设计，分析模型和设计模型不再割裂，并引出了以领域为核心的分层架构，有效地分离业务和技术复杂度，使得领域层的代码和领域模型保持高度一致。在战术上提供了诸多元模式帮助构建职责清晰、内聚和高维护性和可扩展性的代码。

引起软件系统复杂度的主要因素是需求，但实现也是不可忽视的因素。我们分析系统的复杂度时就可以从业务复杂度和技术复杂度这两个维度出发。

DDD的核心思想就是要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，确定业务逻辑与技术实现的边界，从而隔离各自的复杂度，业务逻辑并不关心技术是如何实现的。
无论采用何种技术，只要业务需求不变，业务规则就不会变化。理想状态下，应该保证业务逻辑与技术实现是正交的。DDD通过分层架构与六边形架构确保业务逻辑与技术实现的隔离。

“分层架构”遵循了“关注点分离”原则，将属于业务逻辑的关注点放到领域层（Domain Layer）中，而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）中。同时，领域驱动设计又颇具创见的引入了应用层（Application Layer）。应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作。


不确定性和变化是这个时代的主旋律，业务需要快速上线，并根据用户的反馈不停地调整和升级，有生命力的业务主动寻求变化，不变则亡是很多行业目前的共识，企业应对变化的响应力成了成败的关键。


DDD驱动我们把每一个限界上下文设计成一个个“自治”的单元，自治要满足四个特点：
最小完备是实现自治的基本条件，指的是自治单元履行的职责是根据业务价值的完整性和最小功能集进行设计的，这让自治单元无需求助其他自治单元获得信息，避免了不必要的依赖关系，同时也避免了不必要和不合适的职责添加到该自治单元上。
自我履行意味着由自治单元自身决定要做什么。是否应该履行某职责，由限界上下文拥有的信息来决定。站在自治单元的角度去思考：“如果我拥有了这些信息，我究竟应该履行哪些职责？”这些职责属于当前上下文的活动范围，一旦超出，就该毫不犹豫地将不属于该范围的请求转交给别的上下文。自我履行其实意味着对知识的掌握，为避免风险，你要履行的职责一定是你掌握的知识范畴之内。
稳定空间指的是减少外界变化对限界上下文内部的影响。稳定空间符合开放封闭原则（OCP），即对修改是封闭的，对扩展是开放的，该原则其实体现了一个单元的封闭空间与开放空间。封闭空间体现为对细节的封装与隐藏，开放空间体现为对共性特征的抽象与统一，二者共同确保了整个空间的稳定。
独立进化指的是减少限界上下文的变化对外界的影响。用限界上下文的上下游关系来阐释，则稳定空间寓意下游限界上下文，无论上游怎么变，我自岿然不动。要做到独立进化，就必须保证对外公开接口的稳定性，因为这些接口被众多消费者依赖和调用，一旦发生变更，就会牵一发而动全身。一个独立进化的限界上下文，需要一个稳定、设计良好的接口设计，并在版本上考虑了兼容与演化。


传统的三层架构分而治之、降低耦合、提高复用，但存在弊端，业务逻辑在不同层泄露，导致替换某一层变得困难、难以对核心逻辑完整测试。


Domain Driven Design (DDD) is about mapping business domain concepts into software artifacts.
